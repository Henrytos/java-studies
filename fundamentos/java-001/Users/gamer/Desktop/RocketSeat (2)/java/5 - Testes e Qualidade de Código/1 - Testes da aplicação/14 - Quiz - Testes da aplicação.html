<html><head><title>Questions</title></head><body><h2>Qual a importância dos testes em uma aplicação?</h2><ul><li>Garantir que a aplicação atende aos requisitos do usuário.</li><li>Verificar se a aplicação funciona conforme o esperado.</li><li>Identificar e corrigir erros e falhas antes que a aplicação seja lançada.</li><li>Reduzir o custo de desenvolvimento e manutenção da aplicação.</li><li>Todas as alternativas anteriores estão corretas.</li></ul><h2>Qual a principal diferença entre testes unitários e testes de integração?</h2><ul><li>Os testes unitários testam unidades de código individuais, enquanto os testes de integração testam a interação entre unidades de código.</li><li>Os testes unitários são mais rápidos e fáceis de executar do que os testes de integração.</li><li>Os testes unitários são mais baratos de executar do que os testes de integração.</li><li>Os testes unitários são mais importantes do que os testes de integração.</li><li>Os testes de integração são mais importantes do que os testes unitários.</li></ul><h2>A anotação @InjectMocks é usada para injetar automaticamente instâncias de objetos anotados com @Mock em objetos que são instâncias da classe sendo testada.</h2><ul><li>Verdadeiro</li><li>Falso</li></ul><h2>Ao realizar testes de integração em um aplicativo Spring Boot, você decide verificar se a configuração de segurança está funcionando corretamente. O aplicativo possui um controlador protegido que só deve ser acessado por usuários autenticados. Considere as opções abaixo e assinale a alternativa incorreta</h2><ul><li>Ao usar o Spring Security, é possível configurar roles (papéis) de usuário e vinculá-las aos métodos do controlador para restringir o acesso com base nessas roles.</li><li>O Spring Security fornece anotações, como @Secured e @PreAuthorize, que podem ser usadas nos métodos do controlador para especificar as restrições de segurança.</li><li>No ambiente de teste, você pode usar a anotação @WithMockUser para simular um usuário autenticado durante a execução dos testes de integração.</li><li>O Spring Security não oferece suporte para a configuração de autenticação baseada em tokens JWT (JSON Web Tokens) fora da caixa.</li><li>O método MockMvcResultMatchers.authenticated() pode ser usado para verificar se a resposta do controlador indica que o usuário está autenticado, independentemente de ter as permissões necessárias.</li></ul><h2>Baseado no que foi mostrado em aula, como podemos capturar exceções e validar seu tipo em Java, utilizando o bloco Try-Catch e a assertiva assertThat?</h2><ul><li>Utilizando apenas a assertiva assertThat para capturar e validar exceções.</li><li>Implementando um bloco Try-Catch sem a assertiva assertThat.</li><li>Usando o bloco Try-Catch e verificando o tipo com a assertiva assertThat.</li><li>Não é possível validar o tipo de exceção lançada em Java.</li><li>Utilizando somente o bloco Try-Catch sem a necessidade da assertiva assertThat.</li></ul><h2>Como é abordado o teste de integração feito em aula, da camada de controller para a funcionalidade de cadastro de um job, utilizando JUnit e MockMvc?</h2><ul><li>Validando a camada de serviço diretamente, sem simular um servidor.</li><li>Utilizando apenas o JUnit, sem a necessidade do MockMvc para testes de integração.</li><li>Testando a integração entre as camadas sem a necessidade de configurar o MockMvc.</li><li>Simulando um servidor com o JUnit e verificando a resposta utilizando o MockMvc.</li><li>Verificando a resposta da requisição sem configurar o tipo de requisição (POST) e a URL no MockMvc.</li></ul></body></html>